<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Impact Reversal Training by Sound</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .impact-button {
            width: 100%;
            height: 300px;
            font-size: 2rem;
        }
    </style>
</head>
<body>
    <div class="container mt-5">
        <h1 class="mb-4">Drive Impact Reversal Training by Sound v1.14</h1>

        <!-- 状態1: 初期画面 -->
        <div id="state1">
            <h2>音でドライブインパクトを返すトレーニング</h2>
            <button id="startButton" class="btn btn-primary impact-button">start</button>
            </div>

        <!-- 状態2: トレーニング画面 -->
        <div id="state2" style="display: none;">
            <p>ドライブインパクトの音が鳴ったらインパクトボタンを押して下さい。 / Push the button when the drive impact sound is played.</p>
            <button id="impactButton" class="btn btn-danger impact-button">インパクトボタン / Impact button</button>
        </div>

        <!-- 状態3: 結果画面 -->
        <div id="state3" style="display: none;">
            <h3>結果</h3>
            <div id="resultText">
                <p>経過時間 / Elapsed Time: <span id="resultTimeMs"></span> ms</p>
                <p>フレーム / Frames: <span id="resultTimeFrames"></span> frames (60fps)</p>
            </div>
            <h4 id="resultMessage" class="mt-3"></h4>
            <button id="retryButton" class="btn btn-primary mt-3">もう一度やる</button>
        </div>
    </div>

    

    <script>
        const state1 = document.getElementById('state1');
        const state2 = document.getElementById('state2');
        const state3 = document.getElementById('state3');

        const startButton = document.getElementById('startButton');
        const impactButton = document.getElementById('impactButton');
        const retryButton = document.getElementById('retryButton');

        const resultTimeMs = document.getElementById('resultTimeMs');
        const resultTimeFrames = document.getElementById('resultTimeFrames');
        const resultText = document.getElementById('resultText');
        const resultMessage = document.getElementById('resultMessage');

        let startTime;
        let timer;
        let timeoutTimer; // タイムアウト監視用のタイマー
        let currentMode = 'normal'; // 'normal' or 'fake'
        let activeAudioSource = null; // 再生中の音源を管理
        let trainingStatus = 'idle'; // 'idle', 'waiting', 'playing'

        // Web Audio APIの準備
        let audioContext;
        let audioBuffer;
        let flyingAudioBuffer; // フライング用の音声バッファ
        let fakeAudioBuffers = [];

        // 音声ファイルを読み込んでデコードする関数
        async function setupAudio() {
            if (audioBuffer && flyingAudioBuffer && fakeAudioBuffers.length > 0) return true;

            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error('Web Audio API is not supported in this browser');
                    alert('お使いのブラウザは対応していません。');
                    return false;
                }
            }

            startButton.disabled = true;
            startButton.textContent = 'Loading...';
            try {
                const listResponse = await fetch('fakes_list.json');
                const fakeSoundFilenames = await listResponse.json();
                const fakeSoundPaths = fakeSoundFilenames.map(file => `fakes/${file}`);

                const responses = await Promise.all([
                    fetch('B.wav'),
                    fetch('sfxg_beep_fast.mp3'),
                    ...fakeSoundPaths.map(file => fetch(file))
                ]);

                const arrayBuffers = await Promise.all(responses.map(res => res.arrayBuffer()));
                const decodedAudios = await Promise.all(arrayBuffers.map(ab => audioContext.decodeAudioData(ab)));

                audioBuffer = decodedAudios[0];
                flyingAudioBuffer = decodedAudios[1];
                fakeAudioBuffers = decodedAudios.slice(2);

            } catch (e) {
                console.error('Audio loading failed:', e);
                startButton.textContent = 'Audio failed to load';
                return false;
            } finally {
                startButton.disabled = false;
                startButton.textContent = 'start';
            }
            
            return true;
        }

        // 音声を再生する関数
        function playSound(buffer) {
            if (!audioContext || !buffer) return null;
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.start(0);
            return source;
        }

        // 状態を切り替える関数
        function setState(state) {
            state1.style.display = 'none';
            state2.style.display = 'none';
            state3.style.display = 'none';

            if (state === 1) {
                trainingStatus = 'idle';
                state1.style.display = 'block';
            } else if (state === 2) {
                state2.style.display = 'block';
                startTraining();
            } else if (state === 3) {
                trainingStatus = 'idle';
                state3.style.display = 'block';
            }
        }

        // トレーニング開始処理
        function startTraining() {
            clearTimeout(timer);
            clearTimeout(timeoutTimer); // タイムアウトタイマーもクリア
            if (activeAudioSource) {
                activeAudioSource.onended = null;
                activeAudioSource.stop();
                activeAudioSource = null;
            }
            startTime = undefined;
            trainingStatus = 'waiting';

            const randomTime = Math.random() * 10000 + 5000;

            if (Math.random() < 0.5) {
                currentMode = 'normal';
                timer = setTimeout(() => {
                    trainingStatus = 'playing';
                    activeAudioSource = playSound(audioBuffer);
                    startTime = performance.now();

                    // 1秒後にタイムアウト処理を設定
                    timeoutTimer = setTimeout(() => {
                        resultText.style.color = 'red';
                        resultMessage.textContent = '反応がありませんでした。失敗。 / No reaction. Failed.';
                        resultMessage.style.color = 'red';
                        resultTimeMs.textContent = 'N/A';
                        resultTimeFrames.textContent = 'N/A';
                        setState(3);
                    }, 3000);
                }, randomTime);
            } else {
                currentMode = 'fake';
                timer = setTimeout(() => {
                    trainingStatus = 'playing';
                    const fakeSound = fakeAudioBuffers[Math.floor(Math.random() * fakeAudioBuffers.length)];
                    activeAudioSource = playSound(fakeSound);
                    activeAudioSource.onended = () => {
                        trainingStatus = 'idle';
                        setTimeout(() => setState(2), 100); // 少し待ってから次のトレーニングへ
                    };
                }, randomTime);
            }
        }

        // スタートボタンのクリックイベント
        startButton.addEventListener('click', async () => {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            const audioReady = await setupAudio();
            if (audioReady) {
                setState(2);
            }
        });

        // インパクトボタンのクリックイベント
        impactButton.addEventListener('click', () => {
            if (trainingStatus === 'waiting') {
                // フライング
                playSound(flyingAudioBuffer);
                clearTimeout(timer);
                resultText.style.color = 'red';
                resultMessage.textContent = 'フライングで失敗 / Failed by flying.';
                resultMessage.style.color = 'red';
                resultTimeMs.textContent = 'N/A';
                resultTimeFrames.textContent = 'N/A';
                setState(3);
                return;
            }

            if (trainingStatus === 'playing') {
                if (currentMode === 'fake') {
                    // フェイク音に対してボタンを押した場合
                    if (activeAudioSource) {
                        activeAudioSource.onended = null;
                        activeAudioSource.stop();
                    }
                    resultText.style.color = 'red';
                    resultMessage.textContent = 'ドライブインパクト音ではありません。失敗。 / Not a drive impact sound. Failed.';
                    resultMessage.style.color = 'red';
                    resultTimeMs.textContent = 'N/A';
                    resultTimeFrames.textContent = 'N/A';
                    setState(3);
                    return;
                }

                if (currentMode === 'normal') {
                    // 通常モードでの正常な反応
                    clearTimeout(timeoutTimer); // タイムアウトをキャンセル
                    if (startTime === undefined) return; // 安全策

                    const endTime = performance.now();
                    const elapsedTime = endTime - startTime;
                    const elapsedFrames = elapsedTime / (1000 / 60);

                    resultTimeMs.textContent = elapsedTime.toFixed(2);
                    resultTimeFrames.textContent = elapsedFrames.toFixed(2);

                    if (elapsedFrames >= 27) {
                        resultText.style.color = 'red';
                        resultMessage.textContent = 'インパクト返し失敗 / Failed.';
                        resultMessage.style.color = 'red';
                    } else {
                        resultText.style.color = 'blue';
                        resultMessage.textContent = 'インパクト返し成功 / Succeeded.';
                        resultMessage.style.color = 'blue';
                    }
                    
                    startTime = undefined;
                    setState(3);
                }
            }
            // trainingStatusが'idle'の場合は何もしない
        });

        // もう一度やるボタンのクリックイベント
        retryButton.addEventListener('click', () => {
            setState(2);
        });

        // 初期状態を設定
        setState(1);
    </script>
    <footer class="text-center mt-5 py-3">
        <a href="https://www.youtube.com/@qurihara" target="_blank" rel="noopener noreferrer">&copy; Kazutaka Kurihara</a>
        <h6>※音の再生開始から計測しているので、実際の成功判定とは異なります。/ Note: The measurement starts from the sound playback start, so it is different from the actual success determination.</h6>
    </footer>
</body>
</html>
