<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Impact Reversal Training by Sound</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .impact-button {
            width: 100%;
            height: 300px;
            font-size: 2rem;
        }
    </style>
</head>
<body>
    <div class="container mt-5">
        <h1 class="mb-4">Drive Impact Reversal Training by Sound v1.26</h1>

        <!-- 状態1: 初期画面 -->
        <div id="state1">
            <h2>おじ教授の音声インパクト返し特訓アプリ</h2>
            <div class="form-check mb-3">
                <input class="form-check-input" type="checkbox" id="fakeModeCheckbox">
                <label class="form-check-label" for="fakeModeCheckbox">
                    フェイクあり / With Fakes
                </label>
            </div>
            <button id="startButton" class="btn btn-primary impact-button">start</button>
            <div class="mt-4 p-3 bg-light rounded">
                <h5 class="mb-3">使用方法 / How to Use</h5>
                <ul>
                    <li>スマートフォンやPCのブラウザで動作します。 / Works on smartphone and PC browsers.</li>
                    <li>フェイクありモードではドライブインパクト音の他にフェイク音がランダムに再生されるので、気をつけましょう。 / In "With Fakes" mode, be careful as fake sounds are randomly played in addition to the Drive Impact sound.</li>
                    <li>PCやスマートフォン（iOSは未対応）にゲームコントローラをUSB接続すれば、任意のボタンで使用できます。 / You can use any button if you connect a game controller via USB to your PC or smartphone (except iOS).</li>
                    <li>BGMを鳴らしながら使ったり、映画を見ながら使ったり、いつでも練習してください。 / Practice anytime, even while listening to BGM or watching movies.</li>
                    <li>※音の再生開始から計測しているので、実際の成功判定とは異なります。/ Note: The measurement starts from the sound playback start, so it is different from the actual success determination.</li>
                </ul>
            </div>
            </div>

        <!-- 状態2: トレーニング画面 -->
        <div id="state2" style="display: none;">
            <p>ドライブインパクトの音が鳴ったらインパクトボタンを押して下さい。 / Push the button when the drive impact sound is played.</p>
            <button id="impactButton" class="btn btn-danger impact-button">インパクトボタン / Impact button</button>
        </div>

        <!-- 状態3: 結果画面 -->
        <div id="state3" style="display: none;">
            <h3>結果</h3>
            <div id="resultText">
                <p>経過時間 / Elapsed Time: <span id="resultTimeMs"></span> ms</p>
                <p>フレーム / Frames: <span id="resultTimeFrames"></span> frames (60fps)</p>
            </div>
            <h4 id="resultMessage" class="mt-3"></h4>
            <button id="retryButton" class="btn btn-primary mt-3">もう一度やる</button>
            <a id="tweetButton" href="#" class="btn btn-info mt-3" target="_blank" style="display: none;">Xで結果を共有</a>
        </div>
    </div>

    

    <script>
        const state1 = document.getElementById('state1');
        const state2 = document.getElementById('state2');
        const state3 = document.getElementById('state3');

        const startButton = document.getElementById('startButton');
        const impactButton = document.getElementById('impactButton');
        const retryButton = document.getElementById('retryButton');

        const resultTimeMs = document.getElementById('resultTimeMs');
        const resultTimeFrames = document.getElementById('resultTimeFrames');
        const resultText = document.getElementById('resultText');
        const resultMessage = document.getElementById('resultMessage');
        const tweetButton = document.getElementById('tweetButton');
        const fakeModeCheckbox = document.getElementById('fakeModeCheckbox');

        let startTime;
        let timer;
        let timeoutTimer; // タイムアウト監視用のタイマー
        let currentMode = 'normal'; // 'normal' or 'fake'
        let activeAudioSource = null; // 再生中の音源を管理
        let trainingStatus = 'idle'; // 'idle', 'waiting', 'playing'
        let prevGamepadButtons = {};

        // Web Audio APIの準備
        let audioContext;
        let audioBuffer;
        let flyingAudioBuffer; // フライング用の音声バッファ
        let state2EntrySoundBuffer; // 状態2移行時用の音声バッファ
        let fakeAudioBuffers = [];

        // 音声ファイルを読み込んでデコードする関数
        async function setupAudio() {
            if (audioBuffer && flyingAudioBuffer && fakeAudioBuffers.length > 0 && state2EntrySoundBuffer) return true;

            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error('Web Audio API is not supported in this browser');
                    alert('お使いのブラウザは対応していません。');
                    return false;
                }
            }

            startButton.disabled = true;
            startButton.textContent = 'Loading...';
            try {
                const listResponse = await fetch('fakes_list.json');
                const fakeSoundFilenames = await listResponse.json();
                const fakeSoundPaths = fakeSoundFilenames.map(file => `fakes/${file}`);

                const responses = await Promise.all([
                    fetch('B.wav'),
                    fetch('sfxg_beep_fast.mp3'),
                    fetch('computer-find_mono.mp3'),
                    ...fakeSoundPaths.map(file => fetch(file))
                ]);

                const arrayBuffers = await Promise.all(responses.map(res => res.arrayBuffer()));
                const decodedAudios = await Promise.all(arrayBuffers.map(ab => audioContext.decodeAudioData(ab)));

                audioBuffer = decodedAudios[0];
                flyingAudioBuffer = decodedAudios[1];
                state2EntrySoundBuffer = decodedAudios[2];
                fakeAudioBuffers = decodedAudios.slice(3);

            } catch (e) {
                console.error('Audio loading failed:', e);
                startButton.textContent = 'Audio failed to load';
                return false;
            } finally {
                startButton.disabled = false;
                startButton.textContent = 'start';
            }
            
            return true;
        }

        // 音声を再生する関数
        function playSound(buffer) {
            if (!audioContext || !buffer) return null;
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.start(0);
            return source;
        }

        // 状態を切り替える関数
        function setState(state, params = {}) {
            state1.style.display = 'none';
            state2.style.display = 'none';
            state3.style.display = 'none';
            tweetButton.style.display = 'none'; // 状態切替時にツイートボタンを非表示

            if (state === 1) {
                trainingStatus = 'idle';
                state1.style.display = 'block';
            } else if (state === 2) {
                if (params.skipEntrySound !== true) {
                    playSound(state2EntrySoundBuffer);
                }
                state2.style.display = 'block';
                startTraining();
            } else if (state === 3) {
                trainingStatus = 'idle';
                state3.style.display = 'block';

                // 失敗音を再生
                if (params.playFailSound) {
                    playSound(flyingAudioBuffer);
                }

                // 成功時のみツイートボタンを生成・表示
                if (params.success) {
                    const { elapsedTime, elapsedFrames, isFakeModeChecked } = params.result;
                    const text = `ドライブインパクトを音で聞いて ${elapsedTime.toFixed(2)}ms (${elapsedFrames.toFixed(2)}F) で返しました！`;
                    let hashtags = 'おじ教授の音声インパクト返し特訓アプリ';
                    const url = window.location.href;
                    tweetButton.href = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&hashtags=${encodeURIComponent(hashtags)}&url=${encodeURIComponent(url)}`;
                    tweetButton.style.display = 'inline-block';
                }
            }
        }

        // トレーニング開始処理
        function startTraining() {
            clearTimeout(timer);
            clearTimeout(timeoutTimer); // タイムアウトタイマーもクリア
            if (activeAudioSource) {
                activeAudioSource.onended = null;
                activeAudioSource.stop();
                activeAudioSource = null;
            }
            startTime = undefined;
            trainingStatus = 'waiting';

            const randomTime = Math.random() * 10000 + 5000;

            if (!fakeModeCheckbox.checked) {
                // フェイクなしモード (常に通常モード)
                currentMode = 'normal';
                timer = setTimeout(() => {
                    trainingStatus = 'playing';
                    activeAudioSource = playSound(audioBuffer);
                    startTime = performance.now();

                    // 3秒後にタイムアウト処理を設定
                    timeoutTimer = setTimeout(() => {
                        resultText.style.color = 'red';
                        resultMessage.textContent = '反応がありませんでした。失敗。 / No reaction. Failed.';
                        resultMessage.style.color = 'red';
                        resultTimeMs.textContent = 'N/A';
                        resultTimeFrames.textContent = 'N/A';
                        setState(3, { success: false, playFailSound: true });
                    }, 3000);
                }, randomTime);
            } else {
                // フェイクありモード (現在の50%分岐ロジック)
                if (Math.random() < 0.5) {
                    currentMode = 'normal';
                    timer = setTimeout(() => {
                        trainingStatus = 'playing';
                        activeAudioSource = playSound(audioBuffer);
                        startTime = performance.now();

                        // 3秒後にタイムアウト処理を設定
                        timeoutTimer = setTimeout(() => {
                            resultText.style.color = 'red';
                            resultMessage.textContent = '反応がありませんでした。失敗。 / No reaction. Failed.';
                            resultMessage.style.color = 'red';
                            resultTimeMs.textContent = 'N/A';
                            resultTimeFrames.textContent = 'N/A';
                            setState(3, { success: false, playFailSound: true });
                        }, 3000);
                    }, randomTime);
                } else {
                    currentMode = 'fake';
                    timer = setTimeout(() => {
                        trainingStatus = 'playing';
                        const fakeSound = fakeAudioBuffers[Math.floor(Math.random() * fakeAudioBuffers.length)];
                        activeAudioSource = playSound(fakeSound);
                        activeAudioSource.onended = () => {
                            trainingStatus = 'idle';
                            setTimeout(() => setState(2, { skipEntrySound: true }), 100); // 少し待ってから次のトレーニングへ
                        };
                    }, randomTime);
                }
            }
        }

        // スタートボタンのクリックイベント
        startButton.addEventListener('click', async () => {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            const audioReady = await setupAudio();
            if (audioReady) {
                setState(2);
            }
        });

        // インパクトボタンのクリックイベント
        impactButton.addEventListener('mousedown', () => {
            if (trainingStatus === 'waiting') {
                // フライング
                playSound(flyingAudioBuffer);
                clearTimeout(timer);
                resultText.style.color = 'red';
                resultMessage.textContent = 'フライングで失敗 / Failed by flying.';
                resultMessage.style.color = 'red';
                resultTimeMs.textContent = 'N/A';
                resultTimeFrames.textContent = 'N/A';
                setState(3, { success: false });
                return;
            }

            if (trainingStatus === 'playing') {
                if (currentMode === 'fake') {
                    // フェイク音に対してボタンを押した場合
                    playSound(flyingAudioBuffer);
                    if (activeAudioSource) {
                        activeAudioSource.onended = null;
                        activeAudioSource.stop();
                    }
                    resultText.style.color = 'red';
                    resultMessage.textContent = 'ドライブインパクト音ではありません。失敗。 / Not a drive impact sound. Failed.';
                    resultMessage.style.color = 'red';
                    resultTimeMs.textContent = 'N/A';
                    resultTimeFrames.textContent = 'N/A';
                    setState(3, { success: false });
                    return;
                }

                if (currentMode === 'normal') {
                    // 通常モードでの正常な反応
                    clearTimeout(timeoutTimer); // タイムアウトをキャンセル
                    if (startTime === undefined) return; // 安全策

                    const endTime = performance.now();
                    const elapsedTime = endTime - startTime;
                    const elapsedFrames = elapsedTime / (1000 / 60);

                    resultTimeMs.textContent = elapsedTime.toFixed(2);
                    resultTimeFrames.textContent = elapsedFrames.toFixed(2);

                    if (elapsedFrames >= 27) {
                        resultText.style.color = 'red';
                        resultMessage.textContent = 'インパクト返し失敗 / Failed.';
                        resultMessage.style.color = 'red';
                        setState(3, { success: false, playFailSound: true });
                    } else {
                        resultText.style.color = 'blue';
                        resultMessage.textContent = 'インパクト返し成功 / Succeeded.';
                        resultMessage.style.color = 'blue';
                        setState(3, { success: true, result: { elapsedTime, elapsedFrames } });
                    }
                    
                    startTime = undefined;
                }
            }
            // trainingStatusが'idle'の場合は何もしない
        });;

        // もう一度やるボタンのクリックイベント
        retryButton.addEventListener('click', () => {
            setState(2);
        });

        // ゲームパッドのループ処理
        function gamepadLoop() {
            const gamepads = navigator.getGamepads();
            for (let i = 0; i < gamepads.length; i++) {
                const gamepad = gamepads[i];
                if (gamepad) {
                    gamepad.buttons.forEach((button, buttonIndex) => {
                        const buttonId = `${gamepad.index}-${buttonIndex}`;
                        const isPressed = button.pressed;
                        const wasPressed = prevGamepadButtons[buttonId] || false;

                        if (isPressed && !wasPressed) {
                            // 現在の表示状態に応じて、対応するボタンのクリックイベントを発火
                            if (state1.style.display === 'block') {
                                startButton.click();
                            } else if (state2.style.display === 'block') {
                                impactButton.click();
                            } else if (state3.style.display === 'block') {
                                retryButton.click();
                            }
                        }
                        prevGamepadButtons[buttonId] = isPressed;
                    });
                }
            }
            requestAnimationFrame(gamepadLoop);
        }

        // 初期状態を設定
        setState(1);
        // ゲームパッドの監視を開始
        gamepadLoop();
    </script>
    <footer class="text-center mt-5 py-3">
        <a href="https://www.youtube.com/@qurihara" target="_blank" rel="noopener noreferrer">&copy; Kazutaka Kurihara</a>
    </footer>
</body>
</html>
